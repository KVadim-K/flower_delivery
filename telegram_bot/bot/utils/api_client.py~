import aiohttp
import os
from dotenv import load_dotenv

# Загружаем переменные окружения из файла .env
load_dotenv()

# Получаем URL API из переменной окружения или используем локальный адрес по умолчанию
API_URL = os.getenv("API_URL", "http://127.0.0.1:8000")


# Класс APIClient для взаимодействия с API вашего Django-приложения
class APIClient:
    def __init__(self, token: str):
        """
        Инициализация APIClient с токеном аутентификации и созданием HTTP-сессии.

        :param token: Токен аутентификации для API-запросов.
        """
        self.token = token
        # Создаем асинхронную сессию для выполнения HTTP-запросов
        self.session = aiohttp.ClientSession()

    async def create_order(self, order_items):
        """
        Отправляет запрос на создание заказа в Django-приложение.

        :param order_items: Список товаров для заказа.
        :return: JSON-ответ, содержащий детали созданного заказа, если запрос успешен.
        """
        # Формируем URL и заголовки запроса
        url = f"{API_URL}/orders/api/create/"
        headers = {
            'Authorization': f'Token {self.token}',  # Добавляем токен аутентификации в заголовки
            'Content-Type': 'application/json'  # Указываем тип контента
        }
        # Тело запроса содержит список товаров для создания заказа
        payload = {
            'order_items': order_items
        }
        # Асинхронно отправляем POST-запрос на создание заказа
        async with self.session.post(url, json=payload, headers=headers) as response:
            if response.status == 201:  # Проверяем, что статус ответа успешен
                return await response.json()  # Возвращаем JSON-ответ
            else:
                error = await response.text()  # Получаем текст ошибки, если запрос неудачен
                raise Exception(f"Не удалось создать заказ: {error}")

    async def get_order_status(self, order_id):
        """
        Получает статус заказа по его ID.

        :param order_id: Идентификатор заказа.
        :return: JSON-ответ, содержащий статус заказа, если запрос успешен.
        """
        # Формируем URL для запроса статуса и добавляем заголовки
        url = f"{API_URL}/orders/api/status/{order_id}/"
        headers = {
            'Authorization': f'Token {self.token}',  # Аутентификация по токену
            'Content-Type': 'application/json'  # Указываем тип контента
        }
        # Асинхронно отправляем GET-запрос для получения статуса заказа
        async with self.session.get(url, headers=headers) as response:
            if response.status == 200:  # Проверяем успешность запроса
                return await response.json()  # Возвращаем JSON с информацией о статусе
            else:
                error = await response.text()  # Получаем текст ошибки
                raise Exception(f"Не удалось получить статус заказа: {error}")

    async def link_telegram_id(self, username: str, telegram_id: int):
        """
        Связывает Telegram ID с пользователем Django по username.
        """
        url = f"{API_URL}/users/api/link_telegram_id/"
        headers = {
            'Authorization': f'Token {self.token}',
            'Content-Type': 'application/json'
        }
        payload = {
            'username': username,
            'telegram_id': telegram_id
        }
        async with self.session.post(url, json=payload, headers=headers) as response:
            if response.status == 200:
                return await response.json()
            else:
                error = await response.text()
                raise Exception(f"Не удалось связать Telegram ID: {error}")

    async def get_user_orders(self):
        """
        Получает список заказов пользователя.
        Предполагается наличие эндпоинта /orders/api/user_orders/
        """
        url = f"{API_URL}/orders/api/user_orders/"
        headers = {
            'Authorization': f'Token {self.token}',
            'Content-Type': 'application/json'
        }
        async with self.session.get(url, headers=headers) as response:
            if response.status == 200:
                return await response.json()
            else:
                error = await response.text()
                raise Exception(f"Не удалось получить заказы: {error}")

    async def close(self):
        await self.session.close()